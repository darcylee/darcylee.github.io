---
layout:     post
title:      "Objective－C 实例化"
subtitle:   "OC"
date:       2015-12-1 12:00:00
author:     darcylee
catalog:    true
header-img: "img/post-bg-obj.jpg"
tags: [objective-c, 学习笔记]
---


# 类实例化

类的实例化位导致两个问题：构造函数、析构函数和赋值运算符如何实现，以及如何分配内存。

在 C++ 中，变量默认是“自动的”：除非被声明为static，否则变量仅在自己的定义块中有意义。动态分配的内存可以一直使用，直到调用了free()或者delete。C++ 中，所有对象都遵循这一规则。

然而在 Objective-C 中，所有对象都是动态分配的。其实这也是符合逻辑的，因为 C++ 更加 static，而 Objective-C 则更加动态。除非能够在运行时动态分配内存，否则 Objective-C 实现不了这么多动态的特性。

## 构造函数和初始化函数

### 分配*allocation*和初始化*initialization*的区别
在 `C++` 中，内存分配和对象初始化都是在构造函数中完成的。在 `Objective-C` 中，这是两个不同的函数。

内存分配由类方法 `alloc` 完成，此时将初始化所有的实例数据。实例数据将被初始化为 `0`，除了一个名为`isa`的`NSObject`的指针。这个指针将在运行时指向对象的实际类型。实例数据根据传入的参数初始化为某一特定的值，这一过程将在一个实例方法 `instance method` 中完成。这个方法通常命名为`init`。因此，构造过程被明确地分为两步：内存分配和初始化。`alloc`消息被发送给类，而`init`消息则被发送给由`alloc`创建出来的新的对象。初始化过程不是可选的，`alloc`之后应该跟着`init`，之后，父类的init也会被调用，直到`NSObject`的`init`方法。这一方法完成了很多重要的工作。

在 C`+`+ 中，构造函数的名字是规定好的，必须与类名一致。在 `Objective-C` 中，初始化方法与普通方法没有什么区别。你可以用任何名字，只不过通常都是选用 `init` 这个名字。然而，我们还是强烈建议，**初始化方法名字一定要用`init`或者 `init` 开头的字符串。**


### 使用`alloc`和`init`

调用`alloc`之后将返回一个新的对象，并且应该给这个对象发送一个`init`消息。`init`调用之后也会返回一个对象。通常，这就是初始化完成的对象。有时候，如果使用单例模式，`init`可能会返回另外的对象（单例模式要求始终返回同一对象）。因此，`init`的返回值不应该被忽略。通常，`alloc`和`init`都会在一行上。

c++

```c++
Foo* foo = new Foo;
```

Objective-C

```objc
Foo* foo1 = [Foo alloc];
[foo1 init]; // 这是不好的行为：应该使用 init 的返回值
Foo* foo2 = [Foo alloc];
foo2 = [foo2 init]; // 正确，不过看上去很啰嗦
Foo* foo3 = [[Foo alloc] init]; // 正确，这才是通常的做法
```

为检查内存分配是否成功，C++ 可以判断 new 返回的指针是否是 0（如果使用的是 new(nothrow)运算符）。在 Objective-C 中，检查返回值是否是nil就已经足够了。

### 初始化方法的正确示例代码

一个正确的初始化方法应该有如下特点：

* 名字以 init 开始；
* 返回能够使用的对象；
* 调用父类的 init 方法，直到NSObject的init方法被调用；
* 保存[super init...]的返回值；
* 处理构造期间出现的任何错误，无论是自己的还是父类的。


下面一些代码：

c++

```
class Point2D
{
public:
    Point2D(int x, int y);
private:
    int x;
    int y;
};
Point2D::Point2D(int anX, int anY) {x = anX; y = anY;}
...

Point2D  p1(3,4);
Point2D* p2 = new Point2D(5, 6);
```

Objective-C

```objc
@interface Point2D : NSObject
{
    int x;
    int y;
}

// 注意，在 Objective-C 中，id 类似于 void *
// (id) 就是对象的“一般”类型
-(id) initWithX:(int)anX andY:(int)anY;
@end

@implementation Point2D

-(id) initWithX:(int)anX andY:(int)anY
{
    // 调用父类的初始化方法
    if (!(self = [super init])) // 如果父类是 NSObject，必须进行 init 操作
        return nil; // 如果父类 init 失败，返回 nil
    // 父类调用成功，进行自己的初始化操作
    self->x = anX;
    self->y = anY;
    return self; // 返回指向自己的指针
}
@end

...

Point2D* p1 = [[Point2D alloc] initWithX:3 andY:4];
```

## self = [super init...]

在上一篇提到的代码中，最不可思议的可能就是这句`self = [super init...]`。回想一下，self是每个方法的一个隐藏参数，指向当前对象。因此，这是一个局部变量。那么，为什么我们要改变一个局部变量的值呢？事实上，`self`必须要改变。我们将在下面解释为什么要这样做。

`[super init]`实际上返回不同于当前对象的另外一个对象。单例模式就是这样一种情况。然而， 有一个 API 可以用一个对象替换新分配的对象。`Core Data`（`Apple` 提供的 `Cocoa` 里面的一个 `API`）就是用了这种 `API`，对实例数据做一些特殊的操作，从而让这些数据能够和数据库的字段关联起来。当继承`NSManagedObject`类的时候，就需要仔细对待这种替换。在这种情形下，`self`就要指向两个对象：一个是`alloc`返回的对象，一个是`[super init]`返回的对象。修改`self`的值对代码有一定的影响：每次访问实例数据的时候都是隐式的。

正如下面的代码所示：

```objc
@interface B : A
{
int i;
}

@end

@implementation B

-(id) init
{
    // 此时，self 指向 alloc 返回的值
    // 假设 A 进行了替换操作，返回一个不同的 self
    id newSelf = [super init];
    NSLog(@"%d", i); // 输出 self->i 的值
    self = newSelf; // 有人会认为 i 没有变化
    NSLog(@"%d", i); // 事实上，此时的 self->i, 实际是 newSelf->i,
                     // 和之前的值可能不一样了
    return self;
}

@end
...
B* b = [[B alloc] init];
```

`self = [super init]`简洁明了，也不必担心以后会引入 bug。然而，我们应该注意旧的`self`指向的对象的命运：它必须被释放。第一规则很简单：谁替换`self`指针，谁就要负责处理旧的`self`指针。在这里，也就是`[super init]`负责完成这一操作。例如，如果你创建`NSManagedObject`子类（这个类会执行替换操作），你就不必担心旧的`self`指针。事实上，`NSManagedObject`的开发者必须考虑这种处理。因此，如果你要创建一个执行替换操作的类，你必须知道如何在初始化过程中释放旧有对象。这种操作同错误处理很类似：如果因为非法参数、不可访问的资源造成构造失败，我们要如何处理？

## 初始化错误

初始化出错可能发生在三个地方：

1. 调用[super init...]之前：如果构造函数参数非法，那么初始化应该立即停止；
2. 调用[super init...]期间：如果父类调用失败，那么当前的初始化操作也应该停止；
3. 调用[super init...]之后：例如资源分配失败等。


在上面每一种情形中，只要失败，就应该返回`nil`；相应的处理应该由发生错误的对象去完成。这里，我们主要关心的是1, 3情况。要释放当前对象，我们调用`[self release]`即可。

在调用`dealloc`之后，对象的析构才算完成。因此，`dealloc`的实现必须同初始化方法兼容。事实上，`alloc`将所有的实例数据初始化成 `0` 是相当有用的。

```objc
@interface A : NSObject {
    unsigned int n;
}

-(id) initWithN:(unsigned int)value;
@end

@implementation A

-(id) initWithN:(unsigned int)value
{
    // 第一种情况：参数合法吗？
    if (value == 0) // 我们需要一个正值
    {
        [self release];
        return nil;
    }
    // 第二种情况：父类调用成功吗？
    if (!(self = [super init])) // 即是 self 被替换，它也是父类
        return nil; // 错误发生时，谁负责释放 self？
    // 第三种情况：初始化能够完成吗？
    n = (int)log(value);
    void* p = malloc(n); // 尝试分配资源
    if (!p) // 如果分配失败，我们希望发生错误
    {
        [self release];
        return nil;
    }
}
@end@interface A : NSObject {
    unsigned int n;
}

-(id) initWithN:(unsigned int)value;
@end

@implementation A

-(id) initWithN:(unsigned int)value
{
    // 第一种情况：参数合法吗？
    if (value == 0) // 我们需要一个正值
    {
        [self release];
        return nil;
    }
    // 第二种情况：父类调用成功吗？
    if (!(self = [super init])) // 即是 self 被替换，它也是父类
        return nil; // 错误发生时，谁负责释放 self？
    // 第三种情况：初始化能够完成吗？
    n = (int)log(value);
    void* p = malloc(n); // 尝试分配资源
    if (!p) // 如果分配失败，我们希望发生错误
    {
        [self release];
        return nil;
    }
}
@end
```

## 将构造过程合并为alloc+init

有时候，alloc和init被分割成两个部分显得很罗嗦。幸运的是，我们也可以将其合并在一起。这主要牵扯到 Objective-C 的内存管理机制。简单来说，作为一个构造函数，它的名字必须以类名开头，其行为类似init，但要自己实现alloc。然而，这个对象需要注册到autorelease池中，除非发送retain消息，否则其生命周期是有限制的。以下即是示例代码：

```objc
// 啰嗦的写法
NSNumber* tmp1 = [[NSNumber alloc] initWithFloat:0.0f];
...
[tmp1 release];
// 简洁一些
NSNumber* tmp2 = [NSNumber numberWithFloat:0.0f];
...
// 无需调用 release
```

## 默认构造函数：指定初始化函数

在 `Objective-C` 中，默认构造函数没有实在的意义，因为所有对象都是动态分配内存，也就是说，构造函数都是确定的。但是，一个常用的构造函数确实可以精简代码。事实上，一个正确的初始化过程通常类似于：

```objc
if (!(self = [super init])) // "init" 或其他父类恰当的函数
    return nil;
// 父类初始化成功，继续其他操作……
return self;
```

剪贴复制代码是一个不良习惯。好的做法是，将共同代码放到一个独立的函数中，通常称为“指定初始化函数”。通常这种指定初始化函数会包含很多参数，因为 `Objective-C` 不允许参数有默认值。

```objc
-(id) initWithX:(int)x
{
    return [self initWithX:x andY:0 andZ:0];
}

-(id) initWithX:(int)x andY:(int)y
{
    return [self initWithX:x andY:y andZ:0];
}

// 指定初始化函数
-(id) initWithX:(int)x andY:(int)y andZ:(int)z
{
    if (!(self = [super init]))
        return nil;
    self->x = x;
    self->y = y;
    self->z = z;
    return self;
}
```

如果指定初始化函数没有最大数量的参数，那基本上就没什么用处：

```objc
// 以下代码就有很多重复部分
-(id) initWithX:(int)x // 指定初始化函数
{
    if (!(self = [super init]))
        return nil;
    self->x = x;
    return self;
}

-(id) initWithX:(int)x andY:(int)y
{
    if (![self initWithX:x])
        return nil;
    self->y = y;
    return self;
}

-(id) initWithX:(int)x andY:(int)y andZ:(int)z
{
    if (![self initWithX:x])
        return nil;
    self->y = y;
    self->z = z;
    return self;
}
```

## 初始化列表和实例数据的默认值

`Objective-C` 中不存在 `C++` 构造函数的初始化列表的概念。然而，不同于 `C++`，`Objective-C` 的alloc会将所有实例数据初始化成 `0`，因此指针也会被初始化成`nil`。`C++` 中，对象属性不同于指针，但是在 `Objective-C` 中，所有对象都被当做指针处理。

## 虚构造函数

`Objective-C` 中存在虚构造函数。我们将在后面的章节中详细讲诉这个问题。

## 类构造函数

在 `Objective-C` 中，类本身就是对象，因此它也有自己的构造函数，并且也能够被重定义。它显然是一个类函数，继承自NSObject，其原型是`+(void) initialize`;。

第一次使用这个类或其子类的时候，这个函数将被自动调用。但这并不意味着，对于指定的类，这个函数只被调用一次。事实上，如果子类没有定义`+(void) initialize`;，那么 `Objective-C` 将调用其父类的`+(void) initialize`;。

## 析构函数
在 `C++` 中，析构函数同构造函数一样，是一个特殊的函数。在 `Objective-C` 中，析构函数也是一个普通的实例函数，叫做`dealloc`。`C++` 中，当对象被释放时，析构函数将自动调用；`Objective-C` 也是类似的，但是释放对象的方式有所不同。

析构函数永远不应该被显式调用。在 `C++` 中存在这么一种情况：开发者自己在析构时管理内存池。但是在 `Objective-C` 中没有这种限制。你可以在 `Cocoa` 中使用自定义的内存区域，但是这并不会影响平常的内存的分配、释放机制。

C++

```
class Point2D
{
public:
    ~Point2D();
};

Point2D::~Point2D() {}
```

Objective-C

```objc
@interface Point2D : NSObject
-(void) dealloc; // 该方法可以被重定义
@end

@implementation Point2D
// 在这个例子中，重定义并不需要
-(void) dealloc
{
    [super dealloc]; // 不要忘记调用父类代码
}
@end
```
